---
title: "05-Plotting"
author: "Ronan Hart"
date: '2022-10-13'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Cropping

### Cropping a vector {-}

If you noticed earlier, the highway polyline runs outside of the elevation raster. What if we want to crop the vector so that it falls only within the raster?

For `sf` we'll use the function `st_crop` (which requires an object of class `sf` or `sfc` and the min/max x & y extent we want to crop the feature to). 

```{r rast_ext, eval = T, echo = T, warning = F}
rast_ext <- extent(elev_snow_stk)
rast_ext
class(rast_ext)
```

This extent object is from the `raster` package, not the `sf` package. But if we double chec in the help file for `st_crop`, it says that `y` should be "a numeric vector with named elements xmin, ymin, xmax and ymax, or object of class bbox, or object for which there is an st_bbox method to convert it to a bbox object."  Because an extent object can be converted to a bbox object, we can directly input the extent object in `st_crop`.

```{r cropRoads, eval = T, echo = T, warning = F}
fwy_crop_sf <- st_crop(fwy_sf_proj, rast_ext)
```

```{r checkCrop, eval = T, echo = F}
plot(elev_snow_stk$elevation)
plot(st_geometry(fwy_crop_sf), lwd = 2)
```

### Cropping a raster {-}

We can also easily crop a raster. Let's say we wanted to crop our raster stack down to only the area around our site that's in the Uintas

```{r plotSites, eval = T, echo = T, fig.cap = "the Uintas are that high-elevation mountain range in the middle right of this map", fig.align = 'center'}
plot(elev_snow_stk$elevation)
plot(st_geometry(sites_sf_proj), pch = 16, add = T)
```

First we need to find out what site number that is. We'll use the `text()` function. There is a `text()` function for base R plotting, but the `raster` package adapted that function to plot text from rasters and `Spatial*` objects. Let's use that function, so we need to specify which package it comes from using `raster::`

```{r checkSiteN, eval = T, echo = T}
plot(elev_snow_stk$elevation)
raster::text(sites_sp_proj, labels = "Site", halo = T)
```

Site 8! Let's filter our spatial data to just this site. 

```{r filterSite8, eval = T, echo = T}
# base R
site_8 <- sites_sf_proj[which(sites_sf_proj$Site == 8), ] # remember that you can use this method for sp objects too

# tidyverse
site_8 <- sites_sf_proj %>%
  filter(Site == 8)

site_8
```

But we don't want to crop the raster down to a single point, so let's first make a buffer (5kmX5km) around this specific site. We'll use `st_buffer()` to do so.

```{r buffer, eval = T, echo = T}
buffer <- st_buffer(site_8, dist = 5000) # units are in meters
buffer

ggplot() +
  geom_sf(data = buffer) +
  geom_sf(data = site_8, col = "red", size = 2) +
  coord_sf(datum = st_crs(26912)) # this plots the axes to UTM coordinates instead of latlong coordinates
```

To crop a raster, we'll use the same function we used to crop a `Spatial*` object: `crop`. Remember that I said earlier that any function we perform on a stack of rasters will run for every raster in that stack!

Earlier when we used `crop`, we could just put in the object itself and the function would automatically crop to the extent of that object. But that only works for objects of class `Raster*`, `Spatial*`, or `Extent`. Because our buffer is of class `sf`, we can't just put the object itself in. Instead we need to put in its extent (*or* you could convert the buffer to a `Spatial*` object)

```{r cropRast, eval = T, echo = T}
stack_crop <- crop(elev_snow_stk, extent(buffer))
stack_crop
plot(stack_crop)
```

```{r checkCropR, eval = T, echo = F}
buff_sp <- as(buffer, "Spatial")
plot(stack_crop$elevation)
lines(buff_sp, lwd = 2)
raster::text(sites_sp_proj, labels = "Site", halo = T)
```
